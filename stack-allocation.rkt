#lang racket

(require "utilities.rkt")
(require "platform-structures.rkt")
(require "rule-generator.rkt")

(provide stack-allocate stack-make-assembly stack-deepest-stack)

(define (get-num-used-locals used)
  (+ 1 (apply max (cons -1 (map car used)))))
(define (stack-allocate platform used ssa-assembly)
  (let ((first-local (get-num-used-locals used)))
    (map-curry calculate-stacks platform first-local ssa-assembly)))

(define (get-instruction platform name #:require (required #t))
  (let ((matches (filter (lambda (found) (eq? name (instruction-struct-name found))) (platform-struct-instrs platform))))
    (if (= (length matches) 1)
        (car matches)
        (if required
            (error "Expected exactly one instruction for name:" name)
            (void)))))

(define (get-returns platform line)
  (let* ((ssa-id (first line))
         (instruction-name (second line))
         (instruction (get-instruction platform instruction-name))
         (counts (length (instruction-struct-returns instruction))))
    (assert (<= counts 1) "Multiple stack-based returns not yet supported.")
    (if (= counts 1)
        (list (list 'ssa ssa-id))
        empty)))
(define (get-arguments platform line)
  (let* ((ssa-id (first line))
         (instruction-name (second line))
         (instruction (get-instruction platform instruction-name))
         (counts (instruction-struct-arguments instruction)))
    (if (and (not (empty? counts)) (eq? (second (last counts)) list?))
        (values (- (length counts) 1) #t)
        (values (length counts) #f))))
(define (is-vararg? platform line)
  (member 'vararg (instruction-struct-options (get-instruction platform (second line)))))

(define (get-ssa arg)
  (and (pair? arg) (eq? (first arg) 'ssa) arg))
(define (get-nonssa arg)
  (and (not (and (pair? arg) (eq? (first arg) 'ssa))) arg))
(define (unwrap-ssa arg)
  (second (assert (get-ssa arg) "Expected a SSA:" arg)))

(define (evaluate-stacks platform first-local lines stack) ; stack is stored with top element first, unlike the rest of the system.
  (if (empty? lines)
      (begin
        (assert (empty? stack) "Stack should be empty at the end!")
        empty)
      (let* ((line (car lines))
             (arguments (filter-map get-ssa (cddr line)))
             (remain-args (map get-nonssa (cddr line)))
             (avail-arguments (reverse (take stack (length arguments))))
             (remain-stack (list-tail stack (length arguments)))
             (returns (get-returns platform line)))
        (let-values (((minimum-arguments can-have-more-arguments) (get-arguments platform line)))
          (if can-have-more-arguments
              (assert (>= (length (cddr line)) minimum-arguments) "Too few instruction:" line)
              (assert (= (length (cddr line)) minimum-arguments) "Incorrect number of arguments:" line))
          (let* ((redone-arguments (if can-have-more-arguments
                                       (suffix (take (cddr line) minimum-arguments) (drop (cddr line) minimum-arguments))
                                       (cddr line))))
            ;(trace 'stack stack)
            (if (not (equal? avail-arguments arguments))
                ;(let ((to-insert (calculate-reordering first-local (first setup) (second setup) (third setup) (map unwrap-ssa stack) (map unwrap-ssa (reverse arguments)))))
                ;  (trace 'INSERT to-insert)
                ;  (evaluate-stacks platform first-local setup (append to-insert lines) stack)))
                (string-append "Stack mismatch... TODO: " (~a avail-arguments) " -- " (~a arguments))
                (let ((evaluated (evaluate-stacks platform first-local (cdr lines)
                                                  (append (reverse returns) remain-stack))))
                  (if (string? evaluated)
                      evaluated
                      (cons (list (cons (second line) redone-arguments) 'STK remain-stack 'ARGS arguments); 'REDONE redone-arguments)
                            evaluated)))))))))
  
(define (calculate-stacks platform first-local ssa-assembly)
  (let* ((evaluated (evaluate-stacks platform first-local (cdr ssa-assembly) empty)))
    (assert (not (string? evaluated)) evaluated)
    evaluated))

(define (stack-make-assembly-for-block platform sequence)
  (let* ((lines (map car sequence))
         (instr-refs (map car lines))
         (instrs (map-curry get-instruction platform instr-refs))
         (instr-args (map (lambda (x) (map car (instruction-struct-arguments x))) instrs))
         (argses (map cdr lines))
         (mappings (map zip instr-args argses)))
    (map cons instr-refs mappings)))

(define (stack-make-assembly platform stack-processed)
  (map-curry stack-make-assembly-for-block platform stack-processed))

(define (stack-deepest-line line)
  (assert (eq? (second line) 'STK))
  (length (third line)))
(define (stack-deepest-block block)
  (apply max (map stack-deepest-line block)))
(define (stack-deepest-stack stack-processed)
  (apply max (map stack-deepest-block stack-processed)))

(require "boxdag.rkt")
(provide stack-add-preserve-saving-and-loading)
(define (stack-add-preserve-saving-and-loading platform boxdag)
  (define any #f)
  ; local allocation needs to be improved
  (define next-local
    (let ((dmap (second (assoc 'internal-varcounts (get-boxdag-exports boxdag)))))
      (define (check-local x)
        (if (assoc x dmap)
            (check-local (+ x 1))
            x))
      (check-local (second (assoc 'original dmap)))))
  (define (value-returning-instruction? instr-name)
    (let* ((instr (get-instruction platform instr-name #:require #f))
           (behavior (and (not (void? instr)) (instruction-struct-behavior instr))))
      (and (pair? behavior) (eq? (car behavior) 'push))))
  (define to-replace-for empty)
  (define (add-for-single x)
    (let ((contents (strip-outer-boxes (cdr x))))
      (if (and (pair? contents) (symbol? (car contents)) (value-returning-instruction? (car contents)))
          (begin
            (set! any #t)
            ;(trace 'add-for-single x)
            (begin0 (cons (car x) (make-boxed `(drop (set-local! (boxdag/export internal-varcounts ,next-local ,next-local) ,contents))))
                    (set! to-replace-for (cons (list (car x) next-local) to-replace-for))
                    (set! next-local (+ 1 next-local))))
          x)))
  (define (replace-iter x)
    (cond ((box? x) (replace-iter (unbox x)))
          ((not (pair? x)) x)
          ((and (eq? (car x) 'boxdag/preserve-ref) (assoc (second x) to-replace-for))
           (list 'local (second (assoc (second x) to-replace-for))))
          (else (cons (replace-iter (car x))
                      (replace-iter (cdr x))))))
  (define (replace-in x)
    (if any
        (cons (car x)
              (make-boxed (replace-iter (cdr x))))
        x))
  (set-boxdag-struct-preserved! boxdag (map replace-in (map add-for-single (boxdag-struct-preserved boxdag))))
  ;(when any
  ;  (trace 'BECOMES (boxdag-struct-preserved boxdag)))
  any)
