#lang racket

(require "utilities.rkt")

(provide register-allocate)

(define (register-allocation-required regs block)
  (let ((return-register (car regs)))
    (filter-map (lambda (insn)
                  (cond ((and (eq? (car insn) 'ssa) (eq? (caaddr insn) 'call))
                         (cons (cadr insn) return-register))
                        ((and (eq? (car insn) 'return) (eq? (caadr insn) 'ssa))
                         (cons (cadadr insn) return-register))
                        (else #f)))
                block)))

(define (ssa-listing block)
  (map car block))

(define (ssa-find-unused block)
  (define (search-listing-from listing i)
    (cond ((or (empty? listing) (> (car listing) i)) i)
          ((< (car listing) i) (search-listing-from (cdr listing) i))
          (else (search-listing-from listing (+ i 1)))))
  (search-listing-from (sort (ssa-listing block) <) 0))

(define (ssa-find-unused-beginning block)
  (+ 1 (apply max (cons 0 (ssa-listing block)))))

(define (tree-search haystack needle)
  (cond ((equal? haystack needle) #t)
        ((pair? haystack) (or (tree-search (car haystack) needle)
                              (tree-search (cdr haystack) needle)))
        (else #f)))

(define (ssa-usage-begin block ssaid)
  (find-index (lambda (x) (and (eq? (car x) 'ssa) (= (cadr x) ssaid)))
              block))

(define (ssa-usage-end block ssaid)
  (find-index (lambda (x) (tree-search x (list 'ssa ssaid)))
              block))

(define (ssa-usage-ranges block)
  (map (lambda (ssaid)
         (list ssaid (ssa-usage-begin block ssaid) (ssa-usage-end block ssaid)))
       (ssa-listing block)))

(define (ssa-conflicts block)
  (define (find-conflicts from to)
    (cond ((empty? to) empty)
          ((< (second (car to)) (third from)) (cons (list (first from) (first (car to)))
                                                    (find-conflicts from (cdr to))))
          (else (find-conflicts from (cdr to)))))
  (define (ssa-conflicts-i active)
    (if (empty? active) empty
        (append (find-conflicts (car active) (cdr active)) (ssa-conflicts-i (cdr active)))))
  (ssa-conflicts-i (sort (ssa-usage-ranges block) (lambda (a b) (< (second a) (second b))))))

(define (ssa-preferences block)
  (define (ssa-preferences-iter starts ends) ; looks through the list of starts and ends and finds places where one starts and another ends at the same time.
    (cond ((or (empty? starts) (empty? ends)) empty)
          ((< (cadar starts) (cadar ends)) (ssa-preferences-iter (cdr starts) ends))
          ((> (cadar starts) (cadar ends)) (ssa-preferences-iter starts (cdr ends)))
          (else ; we found a preference!
           (cons (sort (list (caar starts) (caar ends)) <)
                 (if (and (pair? (cdr ends)) (= (cadadr ends) (cadar starts)))
                     (ssa-preferences-iter starts (cdr ends))
                     (ssa-preferences-iter (cdr starts) ends))))))
  (let ((unzipped (unzip (map (lambda (x) (list (list (first x) (second x)) (list (first x) (third x)))) (ssa-usage-ranges block)))))
    (let ((sorted-starts (sort (first unzipped) (lambda (a b) (< (second a) (second b)))))
          (sorted-ends (sort (second unzipped) (lambda (a b) (< (second a) (second b))))))
      (ssa-preferences-iter sorted-starts sorted-ends))))

(define (find-vars-in-register allocation register)
  (filter-map (lambda (kvpair)
                (if (eq? register (cdr kvpair))
                    (car kvpair)
                    #f))
              allocation))

(define (check-not-in-conflict pair val1 val2) ; if each cell contains a different one of the values
  (not (or (and (= (first pair) val1) (= (second pair) val2))
           (and (= (first pair) val2) (= (second pair) val1)))))

(define (color-solve remaining regs conflicts preferences previous-allocation)
  ; (pretty-print (list 'color-solve remaining regs conflicts preferences previous-allocation))
  (if (empty? remaining) (stream previous-allocation)
      (let* ((next (car remaining))
             (rest (cdr remaining))
             (no-conflict-i (lambda (no-conflict-i cflx conflict-register)
                              (let ((conflict-vars (find-vars-in-register previous-allocation conflict-register)))
                                (andmap (lambda (conflict-elem)
                                          (andmap (curry check-not-in-conflict conflict-elem next)
                                                  conflict-vars))
                                        cflx))))
             (without-conflicting (filter (curry no-conflict-i no-conflict-i conflicts) regs))
             (sort-by-preference (lambda (a b) (and
                                                (member a preferences)
                                                (not (member b preferences)))))
             (ordering (sort without-conflicting sort-by-preference))
             (new-allocations (map (lambda (assign) (cons (cons next assign) previous-allocation)) ordering)))
        (stream-append-stream (stream-map
                               (lambda (new-allocation)
                                   (color-solve rest regs conflicts preferences new-allocation))
                               (list->stream new-allocations))))))

(define (register-allocation-apply block lookup)
  (define (fix-tree tree)
    (if (not (pair? tree)) tree
        (if (eq? (first tree) 'ssa) (list 'reg (cdr (assoc (second tree) lookup)))
            (map fix-tree tree))))
  (define (apply-line line)
    (if (eq? (first line) 'ssa)
        (cons 'reg (cons (cdr (assoc (second line) lookup))
                         (fix-tree (cddr line))))
        (cons (first line) (fix-tree (cdr line)))))
  (map apply-line block))

(define (register-allocate-block regs orig-block)
  (let ((block (cdr orig-block)))
    (let ((base-allocation (register-allocation-required regs block))
          (conflicts (ssa-conflicts block))
          (preferences (ssa-preferences block)))
      (let ((result (stream-first (color-solve (without (ssa-listing block) (map car base-allocation)) (cadr regs) conflicts preferences base-allocation))))
        (cons (map cdr result) (register-allocation-apply block result))))))

(define (register-allocate regs tree)
  (let* ((allocated (map (curry register-allocate-block regs) (cdddr tree)))
         (allocated-blocks (map cdr allocated))
         (return-register regs)
         (allocated-used (without (unique (append* (map car allocated))) return-register)))
    (cons allocated-used
          (cons (car tree)
                (cons (cadr tree)
                      (cons (caddr tree)
                            allocated-blocks))))))

(define e-regs '(eax ebx ecx edx esi edi))
(define e-oblk '((ssa 5)
   (0 x86/add/dc (get-reg ebp) 8)
   (1 x86/movfm/d (ssa 0))
   (2 x86/mov/c 2)
   (3 x86/cmp/dd (ssa 1) (ssa 2))
   (4 x86/jge (ssa 3) 2)
   (5 x86/jmp 1)))
(define e-blk (cdr e-oblk))
(register-allocate-block e-regs e-oblk)
