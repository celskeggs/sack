#lang racket

(require "utilities.rkt")
(require "register-constraints.rkt")
(require "graph-color.rkt")

(provide register-allocate register-allocate-real register-allocation-used-registers)

(define (register-allocation-used-registers regs unargified)
  (unique (filter (lambda (x) (member x regs)) (append* (map cdr unargified))) #:cmp< symbol<?))

(define (register-allocate platform regs input)
  (map-curry register-allocate-real regs input))

(define (pair<? a b)
  (or (< (first a) (first b))
      (and (= (first a) (first b))
           (< (second a) (second b)))))

(define (tuple-capable-graph-color regs targets forced conflicts preferences)
  (let* ((tuple-usage-list (unique (filter pair? (append (append* forced)
                                                        (append* conflicts)
                                                        (append* preferences))) #:cmp< pair<?))
        ; the 1000 isn't actually used for anything - it just lets us tell these apart easily for now.
        ; we could easily make it 1.
        (beginning-free (+ 1000 (apply max targets)))
        (new-targets (range beginning-free (+ beginning-free (length tuple-usage-list))))
        (all-targets (append targets new-targets))
        (tuple-mapping (zip tuple-usage-list new-targets)))
    (define (remap-elem elem)
      (if (pair? elem)
          (second (assoc elem tuple-mapping))
          elem))
    (define (remap-pair pair)
      (map remap-elem pair))
    (define (remap-line line)
      (map remap-pair line))
    (cons (map reverse tuple-mapping)
          (disallowed-register-capable-graph-color regs
                                                   all-targets
                                                   (remap-line forced)
                                                   (remap-line conflicts)
                                                   (remap-line preferences)))))

(define (ref<? a b)
  (if (pair? a)
      (if (pair? b)
          (pair<? a b)
          #f)
      (if (pair? b)
          #t
          (< a b))))

(define (disallowed-register-capable-graph-color regs targets forced conflicts preferences)
  (let* ((suspects (filter symbol? (append* forced)))
         (offenders (without suspects regs))
         (offending-ssas (unique (filter-map (lambda (x) (or (and (member (first x) offenders) (second x))
                                                     (and (member (second x) offenders) (first x))))
                                             forced) #:cmp< ref<?))
         (remaining (without targets offending-ssas))
         (extra-conflicts (append* (map (lambda (offender) (map-curry list offender remaining)) offending-ssas)))
         (total-conflicts (append conflicts extra-conflicts)))
    (graph-color
     targets forced total-conflicts preferences)))

(define (register-allocate-real regs block)
  (let* ((seq (first block))
         (code (cdr seq))
         (constraints (second block))
         (all-ssas (map car code))
         (colored (tuple-capable-graph-color regs
                                             all-ssas
                                             (first constraints)
                                             (second constraints)
                                             (third constraints)))
         (assigned (apply (curry assign-registers regs) colored)))
    (cons (insert-ssas code (car assigned))
          (cdr assigned))))

(define (assign-registers regs tuple-abbrevs forced-regs layout)
  (define (get-unabbrev lookup)
    (let ((found (assoc lookup tuple-abbrevs)))
      (if found
          (second found)
          lookup)))
  (let* ((all-used (unique (map second layout) #:cmp< <))
         (unspecified-ssas (without all-used (map first forced-regs)))
         (unused-regs (without regs (map second forced-regs))))
    (assert (<= (length unspecified-ssas) (length unused-regs)) "Insufficient registers... need to implement spilling!")
    (let ((lookup (append forced-regs (zip unspecified-ssas (take unused-regs (length unspecified-ssas))))))
      (cons (map (lambda (pair) (list (get-unabbrev (first pair))
                                      (second (assoc (second pair) lookup))))
                 layout)
            (map second lookup)))))

(define (insert-ssas code tupled-ssas)
  (define ssa-ids (map first tupled-ssas))
  (define abnormal-ssa-ids (unique (map car (filter pair? ssa-ids)) #:cmp< <))
  (define normal-ssas (filter-not (lambda (x) (or (member (car x) abnormal-ssa-ids) (and (pair? (car x)) (member (caar x) abnormal-ssa-ids)))) tupled-ssas))
  (define (make-abnormal-out id)
    (let ((mapping (filter-map (lambda (pair) (and (pair? (car pair)) (= (caar pair) id)
                                                   (list (cadar pair) (cadr pair)))) tupled-ssas)))
      (list id (map->list mapping))))
  (define abnormal-ssas (map make-abnormal-out abnormal-ssa-ids))
  (define untupled-ssas (append normal-ssas abnormal-ssas))
  (define (remap-id id)
    (second (assoc id untupled-ssas)))
  (define (remap-elem elem)
    (cond ((and (pair? elem) (eq? (car elem) 'ssa))
           (if (member (second elem) abnormal-ssa-ids)
               '(reg/undefined)
               (list 'get-reg (remap-id (second elem)))))
          ((and (pair? elem) (eq? (car elem) 'generic/subresult))
           (let ((tgt (second (assoc
                               (list (second (fourth elem)) (second elem))
                               tupled-ssas))))
             (assert (eq? tgt (third elem)) "Mismatched subresult register!")
             (list 'get-reg tgt)))
          (else elem)))
  (define (remap-line line)
    (cons (remap-id (car line)) (map remap-elem (cdr line))))
  (map remap-line code))

;(register-allocate-real '(eax ebx ecx) '(((ssa 5)
;    (0 x86/add/dc (get-reg ebp) 8)
;    (1 x86/movfm/d (ssa 0))
;    (2 x86/mov/c 2)
;    (3 x86/cmp/dd (ssa 1) (ssa 2))
;    (4 x86/jge (ssa 3) 2)
;    (5 x86/jmp 1))
;   ((0 1 2 3 4 5)
;    ((sign-flag-xor-overflow-flag (3 0))
;     (zero-flag (3 1))
;     (carry-flag (3 2)))
;    ((1 2))
;    ((0 1) (1 3) (2 3) (3 4)))))
