#lang racket

(provide stack-based register-based argument-behavior localvar-behavior get-num-used-locals use-standard-reductions call-behavior-stack call-behavior-forward call-behavior-backward)

(require "common.rkt")
(require "platform.rkt")
(require "utilities.rkt")
(require "register-constraints.rkt")
(require "register-allocation.rkt")
(require "stack-allocation.rkt")

(define-syntax-rule (stack-based save load pop)
  (begin
    (platform-pipeline-def (platform ssa-assembly merged-exports stack-processed)
                           (let ((uses (second (or (assoc 'varusages merged-exports)
                                                   (list empty empty)))))
                             (stack-allocate platform uses '(save load pop) ssa-assembly)))
    (platform-pipeline-def (platform stack-processed specified-assembly)
                           (stack-make-assembly platform stack-processed))
    (platform-pipeline-def (platform stack-processed registers-touched)
                           (stack-deepest-stack stack-processed))
    ))
(define-syntax-rule (register-based remap-op (reg ...))
  (begin
    (platform-pipeline-def (platform ssa-assembly register-constraints)
                           (register-constrain platform ssa-assembly))
    (platform-pipeline-def (platform register-constraints register-unargified)
                           (register-allocate platform (platform-struct-registers platform) register-constraints))
    (platform-pipeline-def (platform register-unargified specified-assembly)
                           (instructions-argify platform (map car register-unargified)))
    (platform-pipeline-def (platform register-unargified registers-touched)
                           (register-allocation-used-registers (platform-struct-registers platform) register-unargified))
    (define registers '(reg ...))
    (set! register? (lambda (r) (and (member r registers) #t)))
    (set-reg-remap-op! 'remap-op)
    (set-registers! registers)
    ))
(define (replace-first find replace in #:failure-error failure-error)
  (define (iter in)
    (cond ((equal? find in) (values #t replace))
          ((pair? in)
           (let-values [((found-a out-a) (iter (car in)))]
             (if found-a
                 (values #t (cons out-a (cdr in)))
                 (let-values [((found-b out-b) (iter (cdr in)))]
                   (values found-b (cons out-a out-b))))))
          (else (values #f in))))
  (let-values [((found out) (iter in))]
    (assert found failure-error)
    out))
(define-syntax-rule (argument-behavior argname getter value setter)
  (begin (reduction-simple-gen (arg (argname any?))
                               (replace-first 'argname '(boxdag/export argusages argname argname) 'getter #:failure-error "Expected an argument ref in argument-behavior getter!"))
         (reduction-simple-gen (set-arg! (argname any?) (value any?))
                               (replace-first 'argname '(boxdag/export argusages argname argname) 'setter #:failure-error "Expected an argument ref in argument-behavior setter!"))))
(define-syntax-rule (localvar-behavior (varid varcount) getter value setter)
  (begin (reduction-calc (local (varid any?)) (cur-exports)
                         (let ((vc (second (assoc 'count (second (assoc 'argument-counts cur-exports))))))
                           (list 'local-arg-based varid vc)))
         (reduction-calc (set-local! (varid any?) (value any?)) (cur-exports)
                         (let ((vc (second (assoc 'count (second (assoc 'argument-counts cur-exports))))))
                           (list 'set-local-arg-based! varid value vc)))
         (reduction-simple-gen (local-arg-based (varid any?) (varcount number?))
                               (replace-first 'varid '(boxdag/export varusages varid varid) 'getter #:failure-error "Expected an argument ref in localvar-behavior getter!"))
         (reduction-simple-gen (set-local-arg-based! (varid any?) (value any?) (varcount number?))
                               (replace-first 'varid '(boxdag/export varusages varid varid) 'setter #:failure-error "Expected an argument ref in localvar-behavior getter!"))))
(define (get-num-used-locals get-export)
  (let ((used (get-export 'varusages)))
    (+ 1 (apply max (cons -1 (map car used))))))
(define (const-zero? x)
  (or (equal? x 0)
      (and (pair? x) (eq? (car x) 'const) (= (cadr x) 0))))
(define-syntax-rule (use-standard-reductions)
  (begin
    (reduction-calc (+ (a const?) (b const?)) (_) (wrap-const (+ a b)))
    (reduction-calc (* (a const?) (b const?)) (_) (wrap-const (* a b)))
    (reduction-simple (+ (a any?) (zero const-zero?)) a)
    (reduction-simple (+ (zero const-zero?) (b any?)) b)
    (reduction-simple (- (a any?) (zero const-zero?)) a)
    (reduction-advanced (x any?) (generic/middle-of (generic/middle x)) x)
    (reduction-advanced (x any?) (rest pair?) (generic/middle-of (generic/middle x) . rest) x)
    (reduction-advanced (x any?) (rest pair?) (generic/middle-of x . rest) (generic/middle-of . rest))))
(define-syntax-rule (call-behavior-stack)
  (begin
    (reduction-raw (list (cons 'target symbol?) (cons 'args list?))
                   '(call target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       `(boxdag/preserve (call-raw-n ,target . ,args)))))))
(define-syntax-rule (call-behavior-forward (argn pushexpr) (argn2 popexpr))
  (begin
    (reduction-simple (generic/call-argument-add (argn any?))
                      pushexpr)
    (reduction-simple (generic/call-argument-remove (argn2 any?))
                      popexpr)
    (reduction-raw (list (cons 'target symbol?) (cons 'args list?))
                   '(call target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       (append '(generic/middle-of)
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-add arg))) args)
                               `((generic/middle (boxdag/preserve (call-raw ,target))))
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-remove arg))) args)))))))
(define-syntax-rule (call-behavior-backward (argn pushexpr) (argn2 popexpr))
  (begin
    (reduction-simple (generic/call-argument-add (argn any?))
                      pushexpr)
    (reduction-simple (generic/call-argument-remove (argn2 any?))
                      popexpr)
    (reduction-raw (list (cons 'target symbol?) (cons 'args list?))
                   '(call target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       (append '(generic/middle-of)
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-add arg))) (reverse args))
                               `((generic/middle (boxdag/preserve (call-raw ,target))))
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-remove arg))) (reverse args))))))))

(provide reduce-<= reduce->= reduce-branch reduce-branch-invert)
(define-syntax-rule (reduce-<=)
  (reduction-simple (<= (a any?) (b any?))
                    (logical/or (< a b) (= a b))))
(define-syntax-rule (reduce->=)
  (reduction-simple (>= (a any?) (b any?))
                    (logical/or (> a b) (= a b))))
(define-syntax-rule (reduce-branch)
  (reduction-simple (branch (condition any?) (true number?) (false number?))
                    (generic/middle-of (boxdag/preserve (goto-if condition true)) (generic/middle (goto false)))))
(define-syntax-rule (reduce-branch-invert)
  (reduction-simple (branch (condition any?) (true number?) (false number?))
                    (generic/middle-of (boxdag/preserve (goto-if-not condition false)) (generic/middle (goto true)))))

(provide strings-as-pointers pointers-as-numbers)
(define-syntax-rule (strings-as-pointers)
  (reduction-calc (const-string (str string?)) (_)
                  (let ((ptr (gensym 'cstr)))
                    `(const-pointer (boxdag/export strings ,ptr ,str)))))
(define-syntax-rule (pointers-as-numbers type)
  (reduction-calc (const-pointer (ptr any?)) (_)
                  `(const ,(const-ref ptr) type)))
