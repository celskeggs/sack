#lang racket

(provide stack-based register-based argument-behavior localvar-behavior get-num-used-locals use-standard-reductions call-behavior-stack call-behavior-stack-adv call-behavior-forward call-behavior-backward get-num-used-arguments)

(require "common.rkt")
(require "platform.rkt")
(require "utilities.rkt")
(require "register-constraints.rkt")
(require "register-allocation.rkt")
(require "stack-allocation.rkt")

(define-syntax-rule (stack-based)
  (begin
    (platform-pipeline-def (platform ssa-assembly merged-exports stack-processed)
                           (let ((uses (second (or (assoc 'varusages merged-exports)
                                                   (list empty empty)))))
                             (stack-allocate platform uses ssa-assembly)))
    (platform-pipeline-def (platform stack-processed specified-assembly)
                           (stack-make-assembly platform stack-processed))
    (platform-pipeline-def (platform stack-processed registers-touched)
                           (stack-deepest-stack stack-processed))
    (boxdag-hook stack-add-preserve-saving-and-loading)
    ))
(define-syntax-rule (register-based remap-op (reg ...))
  (begin
    (platform-pipeline-def (platform ssa-assembly register-constraints)
                           (register-constrain platform ssa-assembly))
    (platform-pipeline-def (platform register-constraints register-unargified)
                           (register-allocate platform (platform-struct-registers platform) register-constraints))
    (platform-pipeline-def (platform register-unargified specified-assembly)
                           (instructions-argify platform (map car register-unargified)))
    (platform-pipeline-def (platform register-unargified registers-touched)
                           (register-allocation-used-registers (platform-struct-registers platform) register-unargified))
    (reduction-simple (drop (what any?))
                            what)
    (define registers '(reg ...))
    (set! register? (lambda (r) (and (member r registers) #t)))
    (set-reg-remap-op! 'remap-op)
    (set-registers! registers)
    ))
(define (replace-first find replace in #:failure-error failure-error)
  (define (iter in)
    (cond ((equal? find in) (values #t replace))
          ((pair? in)
           (let-values [((found-a out-a) (iter (car in)))]
             (if found-a
                 (values #t (cons out-a (cdr in)))
                 (let-values [((found-b out-b) (iter (cdr in)))]
                   (values found-b (cons out-a out-b))))))
          (else (values #f in))))
  (let-values [((found out) (iter in))]
    (assert found failure-error)
    out))
(define-syntax-rule (argument-behavior argname getter value setter)
  (begin (reduction-simple-gen (arg (argname any?))
                               (replace-first 'argname '(boxdag/export argusages argname argname) 'getter #:failure-error "Expected an argument ref in argument-behavior getter!"))
         (reduction-simple-gen (set-arg! (argname any?) (value any?))
                               (replace-first 'argname '(boxdag/export argusages argname argname) 'setter #:failure-error "Expected an argument ref in argument-behavior setter!"))))
(define-syntax-rule (localvar-behavior (varid varcount) getter value setter)
  (begin (reduction-calc (local (varid any?)) (cur-exports)
                         (let ((vc (second (assoc 'count (second (assoc 'argument-counts cur-exports))))))
                           (list 'local-arg-based varid vc)))
         (reduction-calc (set-local! (varid any?) (value any?)) (cur-exports)
                         (let ((vc (second (assoc 'count (second (assoc 'argument-counts cur-exports))))))
                           (list 'set-local-arg-based! varid value vc)))
         (reduction-simple-gen (local-arg-based (varid any?) (varcount number?))
                               (replace-first 'varid '(boxdag/export varusages varid varid) 'getter #:failure-error "Expected an argument ref in localvar-behavior getter!"))
         (reduction-simple-gen (set-local-arg-based! (varid any?) (value any?) (varcount number?))
                               (replace-first 'varid '(boxdag/export varusages varid varid) 'setter #:failure-error "Expected an argument ref in localvar-behavior getter!"))))
(define (get-num-used-arguments get-export)
  (second (assoc 'count (get-export 'argument-counts))))
(define (get-num-used-locals get-export)
  (let ((used (get-export 'varusages)))
    (+ 1 (apply max (cons -1 (map car used))))))
(define (const-zero? x)
  (or (equal? x 0)
      (and (pair? x) (eq? (car x) 'const) (equal? (cadr x) 0))))
(define-syntax-rule (use-standard-reductions)
  (begin
    (reduction-calc (+ (a const?) (b const?)) (_) (wrap-const (+ a b)))
    (reduction-calc (* (a const?) (b const?)) (_) (wrap-const (* a b)))
    (reduction-simple (+ (a const?) (b any?)) (+ b a))
    (reduction-simple (+ (a any?) (zero const-zero?)) a)
    (reduction-simple (- (a any?) (zero const-zero?)) a)
    (reduction-advanced (x any?) (generic/middle-of (generic/middle x)) x)
    (reduction-advanced (x any?) (rest pair?) (generic/middle-of (generic/middle x) . rest) x)
    (reduction-advanced (x any?) (rest pair?) (generic/middle-of x . rest) (generic/middle-of . rest))
    (reduction-advanced (x any?) (logical/not (logical/not x)) x)
    (reduction-advanced (cond any?) (true number?) (false number?)
                        (branch (logical/not cond) true false)
                        (branch cond false true))
    ))
(define-syntax-rule (call-behavior-stack)
  (call-behavior-stack-adv #:from call #:to call-raw-n #:target-type symbol?))
(define-syntax-rule (call-behavior-stack-adv #:from from #:to to #:target-type target-type)
  (begin
    (reduction-raw (list (cons 'target target-type) (cons 'args list?))
                   '(from target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       `(boxdag/preserve (to ,target . ,args)))))))
(define-syntax-rule (call-behavior-forward (argn pushexpr) (argn2 popexpr))
  (begin
    (reduction-simple (generic/call-argument-add (argn any?))
                      pushexpr)
    (reduction-simple (generic/call-argument-remove (argn2 any?))
                      popexpr)
    (reduction-raw (list (cons 'target symbol?) (cons 'args list?))
                   '(call target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       (append '(generic/middle-of)
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-add arg))) args)
                               `((generic/middle (boxdag/preserve (call-raw ,target))))
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-remove arg))) args)))))))
(define-syntax-rule (call-behavior-backward (argn pushexpr) (argn2 popexpr))
  (begin
    (reduction-simple (generic/call-argument-add (argn any?))
                      pushexpr)
    (reduction-simple (generic/call-argument-remove (argn2 any?))
                      popexpr)
    (reduction-raw (list (cons 'target symbol?) (cons 'args list?))
                   '(call target . args)
                   (lambda (vars cur-exports)
                     (let ((target (cdr (assoc 'target vars)))
                           (args (cdr (assoc 'args vars))))
                       (append '(generic/middle-of)
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-add arg))) (reverse args))
                               `((generic/middle (boxdag/preserve (call-raw ,target))))
                               (map (lambda (arg) (list 'boxdag/preserve (list 'generic/call-argument-remove arg))) (reverse args))))))))

(provide reduce-<= reduce->= reduce->-flip reduce-<-flip reduce-branch reduce-branch-invert)
(define-syntax-rule (reduce-<=)
  (reduction-simple (<= (a any?) (b any?))
                    (logical/not (> a b))))
(define-syntax-rule (reduce->=)
  (reduction-simple (>= (a any?) (b any?))
                    (logical/not (< a b))))
(define-syntax-rule (reduce->-flip)
  (reduction-simple (> (a any?) (b any?))
                    (< b a)))
(define-syntax-rule (reduce-<-flip)
  (reduction-simple (< (a any?) (b any?))
                    (> b a)))
(define-syntax-rule (reduce-branch)
  (reduction-simple (branch (condition any?) (true number?) (false number?))
                    (generic/middle-of (boxdag/preserve (goto-if condition true)) (generic/middle (goto false)))))
(define-syntax-rule (reduce-branch-invert)
  (reduction-simple (branch (condition any?) (true number?) (false number?))
                    (generic/middle-of (boxdag/preserve (goto-if-not condition false)) (generic/middle (goto true)))))
(define-syntax-rule (reduce-goto-logical/not #:to-goto-if to-goto-if #:to-goto-if-not to-goto-if-not)
  (begin
    (when to-goto-if
      (reduction-advanced (x any?) (target number?) (goto-if (logical/not x) target) (goto-if-not x target)))
    (when to-goto-if-not
      (reduction-advanced (x any?) (target number?) (goto-if-not (logical/not x) target) (goto-if x target)))))

(provide strings-as-pointers pointers-as-numbers booleans-as-0-1)
(define-syntax-rule (strings-as-pointers)
  (reduction-calc (const-string (str string?)) (_)
                  (let ((ptr (gensym 'cstr)))
                    `(const-pointer (boxdag/export strings ,ptr ,str)))))
(define-syntax-rule (pointers-as-numbers type)
  (reduction-calc (const-pointer (ptr any?)) (_)
                  `(const ,(const-ref ptr) type)))
(define-syntax-rule (booleans-as-0-1)
  (begin
    (reduction-advanced (const-boolean #f)
                        (const 0 u4))
    (reduction-advanced (const-boolean #t)
                        (const 1 u4))))
