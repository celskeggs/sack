#lang racket

(provide full-ssaify)

(require "utilities.rkt")
(require "boxdag.rkt")
(require "platform-structures.rkt")
(require "rule-generator.rkt")

(struct ssaified-reference (ref stmts) #:inspector #f)

(define (make-ssaified-reference pair)
  (ssaified-reference (car pair) (cdr pair)))
(define (get-ssa)
  (box (void)))
(define (is-simple-ref x)
  (member (car x) '(get-reg generic/subresult)))
(define (get-instruction platform name)
  (let ((matches (filter (lambda (found) (eq? name (instruction-struct-name found))) (platform-struct-instrs platform))))
    (and (= (length matches) 1) (car matches))))
(define (avoid-deduplication? platform instruction)
  (let ((instr (get-instruction platform instruction)))
    (and instr (instruction-option? instr 'no-deduplicate))))
(define (replace-get-reg reg-mover x)
  (cond ((void? reg-mover) x)
        ((and (pair? x) (eq? (car x) 'get-reg))
         (list reg-mover x))
        ((and (pair? x) (eq? (car x) 'generic/subresult))
         (list reg-mover x))
        ((pair? x)
         (cons (replace-get-reg reg-mover (car x))
               (replace-get-reg reg-mover (cdr x))))
        ((box? x)
         (set-box! x (replace-get-reg reg-mover (unbox x)))
         x)
        (else x)))
(define (ssaify platform x (is-top-level #f)) ; returns ('ssa ssa-id) . ((ssa . code) (ssa . code) ...) OR x . empty
  (cond ((and (pair? x) (eq? (car x) 'boxdag/preserve-ref))
         (cons (second x) empty))
        ((and (pair? x) (not (is-simple-ref x)))
         (let ((gotten (ssaify-node platform x)))
           (cons (list 'ssa (car gotten)) (cdr gotten))))
        ((pair? x)
         (let ((name (car x)) (rest (ssaify-all platform (cdr x))))
           (cons (cons name (car rest)) (cdr rest))))
        ((and (box? x) is-top-level)
         (ssaify platform (unbox x)))
        ((and (box? x) (pair? (unbox x)) (avoid-deduplication? platform (car (unbox x))))
         (ssaify platform (unbox x)))
        ((and (box? x) (ssaified-reference? (unbox x)))
         (cons (ssaified-reference-ref (unbox x)) empty))
        ((box? x)
         (set-box! x (make-ssaified-reference (ssaify platform (unbox x))))
         (cons (ssaified-reference-ref (unbox x)) (ssaified-reference-stmts (unbox x))))
        (else (cons x empty))))
(define (ssaify-all platform xes) ; returns (('ssa ssa-id) OR x ...) . ((ssa . code) (ssa . code) ...)
  (let ((processed (map-curry ssaify platform xes)))
    (cons (map car processed) (append* (map cdr processed)))))
(define (ssaify-node platform x) ; returns ssa-id (ssa . code) (ssa . code) ...
  (let* ((name (car x))
         (processed (ssaify-all platform (cdr x)))
         (args (car processed))
         (stmts (cdr processed))
         (ssa (get-ssa)))
    (unless (symbol? name)
      (error "Expected a symbol head:" name))
    (cons ssa (suffix stmts
                      (cons ssa (cons name args))))))
(define (replace-all x replacements)
  (cond [(assoc x replacements) (cdr (assoc x replacements))]
        [(pair? x) (cons (replace-all (car x) replacements)
                         (replace-all (cdr x) replacements))]
        [(box? x) (set-box! x (replace-all (unbox x) replacements))
                  x]
        [else x]))
(define (ssaify-multi-element platform reg-mover x)
  (let* ((ssa-out (car x))
         (repl (replace-get-reg reg-mover (cdr x)))
         (ssaified (ssaify platform repl #t)))
    ;(trace 'REPL x repl (car ssaified))
    (when (box? ssa-out)
      ;(assert (eq? (caar ssaified) 'ssa)) ; I think this is a valid assumption?
      ;(set-box! ssa-out (list 'ssa (cadar ssaified) 'probable-slot)))
      (set-box! ssa-out (car ssaified)))
    ssaified))
(define (ssaify-multi platform reg-mover x) ; returns ssa-id (ssa . code) (ssa . code) ...
  (let ((targets (map car x)))
    (assert (= 1 (length (filter empty? targets))) "Should be exactly one result preserve!")
    (assert (empty? (last targets)) "The last preserve should be the result preserve!")
    (let* ((replacements (map (lambda (target) (cons target (get-ssa)))
                             (filter (lambda (x) (not (empty? x))) targets)))
           (replaced (replace-all x replacements)))
      ;(trace 'REPLACED replaced)
      (let ((processed (map-curry ssaify-multi-element platform reg-mover replaced)))
        (cons (car (last processed))
              (append* (map cdr processed)))))))

(define (assign-ssa pair)
  (assert (void? (unbox (cadr pair))) "Expected ssa to be unassigned.")
  (set-box! (cadr pair) (car pair)))
(define (assign-ssas x)
  (map assign-ssa (enumerate (cdr x)))
  (strip-boxes x))

; Note that full-ssaify will mangle the boxdag's contents.
(define (full-ssaify platform x)
  ;(trace 'full-ssaify x)
  (assign-ssas (ssaify-multi platform (platform-struct-reg-remap-op platform) x)))
