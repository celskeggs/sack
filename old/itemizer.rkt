#lang racket

(require "utilities.rkt")

(provide itemize)

(define sample '(fib (u4) u4
                     ((branch (<= (arg 0) (const 1 u4)) 1 2))
                     ((return (const 1 u4)))
                     ((return (+ (call fib (- (arg 0) (const 1 u4)))
                                 (call fib (- (arg 0) (const 2 u4))))))))

(define simple-binary-operations '(<= >= < > == != + - * / %))

(define (itemize tree)
  (let ((name (car tree)) (args (cadr tree)) (rettype (caddr tree)) (body (cdddr tree)))
    
    (define (get-swr)
      (make-placeholder 'unallocated-swr))
    (define (recurse-set-swr tree next-id) ; return tree and then next ID
      (cond ((and (placeholder? tree) (eq? (placeholder-get tree) 'unallocated-swr))
             (placeholder-set! tree next-id)
             (cons tree (+ next-id 1)))
            ((pair? tree)
             (let* ((first-alloc (recurse-set-swr (car tree) next-id))
                    (head (car first-alloc))
                    (intermediate-id (cdr first-alloc))
                    (second-alloc (recurse-set-swr (cdr tree) intermediate-id))
                    (tail (car second-alloc))
                    (final-id (cdr second-alloc)))
               (cons (cons head tail) final-id)))
            (else (cons tree next-id))))
    (define (assign-swr tree)
      (make-reader-graph (car (recurse-set-swr tree 0))))
    (define (itemize-expr-simple-binary type a b)
      (let* ((itemized-a (itemize-expr a))
             (itemized-b (itemize-expr b))
             (swr-id-a (car itemized-a))
             (swr-id-b (car itemized-b))
             (statements-a (cdr itemized-a))
             (statements-b (cdr itemized-b))
             (swr-id-out (get-swr)))
        (cons swr-id-out
              (suffix (append statements-a statements-b)
                      `(swr ,swr-id-out (,type (swr ,swr-id-a) (swr ,swr-id-b)))))))
    (define (itemize-expr-arg arg-id)
      (let ((swr-id-out (get-swr)))
        (cons swr-id-out
              (list `(swr ,swr-id-out (arg ,arg-id))))))
    (define (itemize-expr-const value type)
      (let ((swr-id-out (get-swr)))
        (cons swr-id-out
              (list `(swr ,swr-id-out (const ,value ,type))))))
    (define (itemize-expr-call fname args)
      (let* ((itemized-all (map itemize-expr args))
             (swr-id-all (map car itemized-all))
             (statements-all (map cdr itemized-all))
             (swr-id-out (get-swr)))
        (cons swr-id-out
              (suffix (append* statements-all)
                      (list 'swr swr-id-out (append (list 'call fname) (map (lambda (swr-id) (list 'swr swr-id)) swr-id-all)))))))
    (define (itemize-expr-node type args)
      (cond ((member type simple-binary-operations)
             (assert (= (length args) 2) "Wrong number of arguments to binary operation.")
             (apply itemize-expr-simple-binary (cons type args)))
            ((eq? type 'arg)
             (assert (= (length args) 1) "Wrong number of arguments to arg ref.")
             (apply itemize-expr-arg args))
            ((eq? type 'const)
             (assert (= (length args) 2) "Wrong number of arguments to const ref.")
             (apply itemize-expr-const args))
            ((eq? type 'call)
             (assert (>= (length args) 1) "Too few arguments to call.")
             (itemize-expr-call (car args) (cdr args)))
            (else (error "Itemization of expression" type "not yet implemented."))))
    (define (itemize-expr expr)
      (assert (pair? expr) "Expected a node expression.")
      (itemize-expr-node (car expr) (cdr expr)))
    (define (itemize-stmt-branch expr iftrue iffalse)
      (let* ((itemized (itemize-expr expr))
             (swr-id (car itemized))
             (statements (cdr itemized)))
        (suffix statements
                `(branch (swr ,swr-id) ,iftrue ,iffalse))))
    (define (itemize-stmt-return expr)
      (let* ((itemized (itemize-expr expr))
             (swr-id (car itemized))
             (statements (cdr itemized)))
        (suffix statements
                `(return (swr ,swr-id)))))
    (define (itemize-final-stmt type args)
      (cond ((eq? type 'branch) (assert (= (length args) 3) "Wrong number of arguments to branch statement.")
                                (apply itemize-stmt-branch args))
            ((eq? type 'return) (assert (= (length args) 1) "Wrong number of arguments to return statement.")
                                (apply itemize-stmt-return args))
            (else (error "Itemization of statement" type "not yet implemented."))))
    (define (itemize-mid-stmt type args)
      (error "Itemization of nonfinal statements is not yet implemented."))
    
    (define (itemize-block-i block)
      (cond ((empty? block) (error "Cannot itemize an empty block."))
            ((empty? (cdr block)) (itemize-final-stmt (caar block) (cdar block)))
            (else (append (itemize-mid-stmt (caar block) (cdar block)) (itemize-block-i (cdr block))))))
    
    (define (itemize-block block)
      (assign-swr (itemize-block-i block)))
    
    (cons name (cons args (cons rettype (map itemize-block body))))))

;(itemize sample)