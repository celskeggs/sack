#lang racket

(require "utilities.rkt")

(define functions empty)
(define (define-function! name maxvars code)
  (assert (not (assoc name functions)) "Duplicate function:" name)
  (set! functions (cons (list name maxvars code) functions)))
(define (define-native-function! name proc)
  (assert (not (assoc name functions)) "Duplicate function:" name)
  (assert (procedure? proc) "Natives must be Racket procedures!")
  (set! functions (cons (list name proc) functions)))
(define instructions empty)
(define-syntax-rule (define-instruction! (name args ... vars stack) code ...)
  (let ((internal (lambda (vars stack args ...)
                    code ...)))
    (assert (not (assoc 'name instructions)) "Duplicate instruction:" 'name)
    (set! instructions (cons (list 'name
                                   (lambda (rawargs rawvars rawstack)
                                     (apply internal (list* rawvars rawstack rawargs))))
                                   instructions))))
(define (invoke-instruction line vars stack)
  (let ((instr (assoc (car line) instructions)))
    (if (not instr)
        (error "Unknown instruction in" line)
        ((second instr) (cdr line) vars stack))))
(define (invoke-seq seq code vars (stack empty))
  (let-values (((value should-jump should-return) (invoke-instruction (car seq) vars stack)))
    (if should-jump
        (invoke-seq (cdr (assoc value code)) code vars)
        (if should-return
            value
            (invoke-seq (cdr seq) code vars value)))))
(define (invoke-code code maxvars args)
  (let ((vars (make-vector maxvars (void))))
    (for [(value (enumerate args))]
      (vector-set! vars (car value) (cdr value)))
    (invoke-seq (cdar code) code vars)))
(define (invoke name args)
  (let ((target (assoc name functions)))
    (assert target "No such function:" name)
    (if (procedure? (cadr target))
        (apply (cadr target) args)
        (invoke-code (caddr target) (cadr target) args))))

(define-instruction! (slot? slot-id vars stack)
  (values (cons (vector-ref vars slot-id) stack) #f #f))
(define-instruction! (slot! slot-id vars stack)
  (vector-set! vars slot-id (car stack))
  (values (cdr stack) #f #f))
(define-instruction! (pop vars stack)
  (values (cdr stack) #f #f))

(define-instruction! (const value vars stack)
  (assert (number? value) "Expected a number.")
  (values (cons value stack) #f #f))
(define-instruction! (const-string value vars stack)
  (assert (string? value) "Expected a string.")
  (values (cons value stack) #f #f))

(define-instruction! (cmplt vars stack)
  (values (cons (< (second stack) (first stack)) (cddr stack)) #f #f))

(define-instruction! (add vars stack)
  (values (cons (+ (second stack) (first stack)) (cddr stack)) #f #f))
(define-instruction! (sub vars stack)
  (values (cons (- (second stack) (first stack)) (cddr stack)) #f #f))

(define-instruction! (jumpif target vars stack)
  (if (car stack)
      (values target #t #f)
      (values (cdr stack) #f #f)))
(define-instruction! (jump target vars stack)
  (values target #t #f))

(define-instruction! (invoke name argcount vars stack)
  (values (cons (invoke name (reverse (take stack argcount))) (drop stack argcount)) #f #f))
(define-instruction! (ret vars stack)
  (values (car stack) #f #t))

(define-native-function! 'printf trace)

(define-syntax-rule (FUNCTION name maxvars label ...)
  (define-function! 'name maxvars (list label ...)))
(define-syntax-rule (LABEL name code ...)
  '(name code ...))

(FUNCTION fib 3
 (LABEL L.0
  (slot? 0)
  (const 2)
  (cmplt)
  (jumpif L.1)
  (jump L.2)
 )
 (LABEL L.1
  (const 1)
  (ret)
 )
 (LABEL L.2
  (slot? 0)
  (const 1)
  (sub)
  (invoke fib 1)
  (slot! 1)
  (slot? 0)
  (const 2)
  (sub)
  (invoke fib 1)
  (slot! 2)
  (slot? 1)
  (slot? 2)
  (add)
  (ret)
 )
)
(FUNCTION main 3
 (LABEL L.0
  (const 0)
  (slot! 0)
  (jump L.1)
 )
 (LABEL L.1
  (slot? 0)
  (const 10)
  (cmplt)
  (jumpif L.2)
  (jump L.3)
 )
 (LABEL L.2
  (slot? 0)
  (invoke fib 1)
  (slot! 1)
  (const-string "fib(%d) = %d\n")
  (slot? 0)
  (slot? 1)
  (invoke printf 3)
  (slot! 2)
  (slot? 2)
  (pop)
  (const 1)
  (slot? 0)
  (add)
  (slot! 0)
  (jump L.1)
 )
 (LABEL L.3
  (const 0)
  (ret)
 )
)

functions
(invoke 'main (list))
