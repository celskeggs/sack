#lang racket

(require "utilities.rkt")
(require "platform.rkt")
(require "rule-generator.rkt")

(provide register-constrain instructions-argify)

; Issue is a range (a b) where the endpoints invariably conflict in register allocation
; To fix this, we assign the former a new SSA in between a and b and copy into it.
(define (mitigate block issue remap-op)
  (define remap-target (+ 1 (car issue)))
  (define (remap-id ssa-id)
    (if (<= ssa-id (car issue)) ssa-id (+ 1 ssa-id)))
  (define (remap-arg line-ssa arg)
    (if (and (pair? arg) (eq? (car arg) 'ssa))
        (if (and line-ssa (= line-ssa (cadr issue)) (= (cadr arg) (car issue)))
            (cons 'ssa (cons remap-target (cddr arg)))
            (cons 'ssa (cons (remap-id (cadr arg)) (cddr arg))))
        arg))
  (define (remap-line line)
    (cons (remap-id (car line)) (map (curry remap-arg (car line)) (cdr line))))
  (define (insert-ssa block entry)
    (if (< (caar block) (car entry))
        (cons (car block) (insert-ssa (cdr block) entry))
        (cons entry block)))
  (cons (remap-arg #f (car block))
        (insert-ssa (map remap-line (cdr block))
                    (list remap-target remap-op (list 'ssa (car issue))))))

(define (instructions-argify platform code)
  (define (get-instruction name)
    (car (filter (lambda (found) (eq? name (instruction-struct-name found))) (platform-struct-instrs platform))))
  (define (remove-get-reg expr)
    (if (and (pair? expr) (eq? (first expr) 'get-reg))
        (second expr)
        expr))
  (define (single-argify line)
    (let* ((out-regs (car line))
           (name (cadr line))
           (arguments (cddr line))
           (instr (get-instruction name))
           (i-args (instruction-struct-arguments instr))
           (i-rets (instruction-struct-returns instr))
           (remain-args (filter (lambda (x) (not (member (car x) i-rets))) i-args))
           (cstrts (instruction-struct-constraints instr))
           (amap (zip (map car (instruction-struct-used-arguments instr)) arguments))
           (rmap (cond ((empty? i-rets) empty)
                       ((empty? (cdr i-rets)) (list (list (car i-rets) (list 'get-reg out-regs))))
                       (else (zip i-rets (map-curry list 'get-reg out-regs)))))
           (tmap (map-join amap rmap)))
      (assert (= (length (unique i-rets)) (length i-rets)) "bad i-rets")
      (assert (= (- (length i-args) (length remain-args)) (length i-rets)) "invalid argset")
      ;(trace 'ARGIFY-1 out-regs name arguments)
      ;(trace 'ARGIFY-2 i-args i-rets remain-args)
      ;(trace 'ARGIFY-3 cstrts amap rmap)
      ;(trace 'ARGIFY i-args tmap)
      (assert (equal? (sort (map car i-args) symbol<?)
                      (sort (map car tmap) symbol<?)) "Key mismatch!")
      (cons name (map (lambda (pair) (list (first pair) (remove-get-reg (second pair)))) tmap))));(map (lambda (key) (remove-get-reg (second (assoc (car key) tmap)))) i-args))))
  (define (block-argify block)
    (map single-argify block))
  (map block-argify code))

(define (register-constrain platform code)
  (define blocks (cdddr code))
  (define (get-instruction name)
    (let ((matches (filter (lambda (found) (eq? name (instruction-struct-name found))) (platform-struct-instrs platform))))
      (assert (= (length matches) 1) (string-append "Expected exactly one instruction for name: " (symbol->string name)))
      (car matches)))
  (define (get-elem k m)
    (let ((found (assoc k m)))
      (and found (cdr found))))
  (define (single-forces line)
    (let* ((out-ssa (car line))
           (name (cadr line))
           (arguments (cddr line))
           (instr (get-instruction name))
           (i-args (instruction-struct-arguments instr))
           (i-rets (instruction-struct-returns instr))
           (remain-args (filter (lambda (x) (not (member (car x) i-rets))) i-args))
           (cstrts (instruction-struct-constraints instr))
           (amap (zip (map car (instruction-struct-used-arguments instr)) arguments))
           (pmap (filter-map (lambda (x) (and (and (pair? (cdr x)) (eq? (cadr x) 'ssa)) (cons (car x) (caddr x)))) (map (curry apply cons) amap))))
      (assert (= (length (unique i-rets)) (length i-rets)) "bad i-rets")
      (assert (= (- (length i-args) (length remain-args)) (length i-rets)) "invalid argset")
      (append
       (filter car (map (lambda (argp) (list (get-elem (car argp) cstrts) (cdr argp))) pmap))
       (let ((rets (instruction-struct-returns instr)))
         (if (= (length rets) 1)
             (filter car (list (list (or (get-elem (car rets) cstrts) (get-elem (car rets) pmap)) out-ssa)))
             (map (lambda (reti) (list (or (get-elem (cdr reti) cstrts) (get-elem (cdr reti) pmap)) (list out-ssa (car reti)))) (enumerate rets)))))))
  (define (ssa-forces blk)
    (append* (map single-forces (cdr blk))))
  (define (ssa-end blk ssa)
    (let ((uses (filter-map (lambda (line) (and (member (list 'ssa ssa) line) (car line))) blk)))
      (and (not (empty? uses)) (apply max uses))))
  (define (ssa-range blk ssa)
    (let ((end (ssa-end blk ssa)))
      (list ssa (or end ssa))))
  (define (ssa-conflicts ranges)
    (if (empty? ranges) empty
        (let ((start (caar ranges))
              (end (cadar ranges)))
          (append (filter-map (lambda (x) (and (< (car x) end) (list start (car x)))) (cdr ranges))
                  (ssa-conflicts (cdr ranges))))))
  (define (ssa-interferences blk)
    (let* ((ssas (map car (cdr blk)))
           (ranges (filter-map (curry ssa-range (cdr blk)) ssas)))
      (ssa-conflicts ranges)))
  (define (ssa-preferences blk)
    (let* ((ssas (map car (cdr blk)))
           (ranges (filter-map (curry ssa-range (cdr blk)) ssas)))
      (append-map (lambda (x) (filter-map (lambda (e) (and (= x (second e)) (not (= x (first e))) (list (first e) x))) ranges)) (map car ranges))))
  (define (constrain-once block)
    (list (ssa-forces block)
          (ssa-interferences block)
          (ssa-preferences block)))
  (define (constrain-issues constraints)
    (let ((forces (first constraints))
          (interferences (second constraints)))
      (filter (lambda (x) (member x interferences)) forces)))
  (define (constrain-bad? constraints)
    (not (empty? (constrain-issues constraints))))
  (define (constrain-loop block)
    (let ((constraints (constrain-once block)))
      (if (constrain-bad? constraints)
          (constrain-loop (mitigate block (car (constrain-issues constraints)) (platform-struct-reg-remap-op platform)))
          (list block constraints))))
  (map constrain-loop blocks))
